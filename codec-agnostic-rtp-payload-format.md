--
docname: draft-codec-agnostic-rtp-payload-format-00
title: Codec agnostic RTP payload format for video
category: std
ipr: trust200902
area: ART
workgroup: AVTCORE
stand_alone: yes

pi: [toc, sortrefs, symrefs]

author:
-
  ins: S. Garcia Murillo
  name: Sergio Garcia Murillo
  org: CoSMo
  email: sergio.garcia.murillo@cosmosoftware.io

-
  ins: A. Gouaillard
  name: Alex Gouaillard
  org: CoSMo
  email: alex.gouaillard@cosmosoftware.io

normative:
  RFC2119:
  RFC3550:
  RFC3711:
  RFC4566:
  RFC8285:

informative:
  RFC6464:
  RFC6465:
  RFC6904:
  SFrame:

--- abstract



--- middle

Introduction
============

The objective of this spec is to create a generic RTP packetization format that can be used with any video codec or encrypted content and that allows SFUs to perform layer selection without requiring access to the codec payload.

RTP packetization
=======================

A generic packetizer, by design, is not expected to understand the format of the media to transmit.
The unit used by the packetizer to do processing is called a frame in the remainder of the document.

It is the responsibility of the application using the packetizer to group media content in meaningful frames.
In the common case of a video codec, the packetizer frame is the frame in byte format (h264 annex b for example) generated by the encoder.
The packetizer can fragment, in a content-agnostic way, the frame in multiple RTP packets to ensure packets do not exceed the network maximum transmission unit.

In the case of a video codec supporting spatial scalability, each spatial layer is split in its own frame.
The spatial layers are sent in ascending order, with the same RTP timestamp, and only the last RTP packet of the last spatial layer frame will have the marker bit set to 1.

If the application wants to encrypt content, the application will split media content into frames before encryption.
Each frame will be encrypted independently, using {{SFrame}} for instance, and transmitted by the packetizer.

Payload multiplexing
=======================

In order to reduce the number of payload type codes on the SDP exchange, a single payload type code for the generic packetization can be used for each media type. That requires to identify the original payload type code for the negotiated media format that the frame belongs to.

The associated payload type will be sent in a header extension. The payload of associated payload header extension element can be encoded using either the one-byte or two-byte header defined in [[RFC5285]].

Figures 1 and 2 show sample encoding with each of these header formats.

```
                    0                   1
                    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |  ID   | len=0 |S|     APT     |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
Figure 1: Sample Associated Payload Type Encoding Using the One-Byte Header Format

```
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      ID       |     len=1     |S|     APT     |    0 (pad)    |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
Figure 2: Sample Associated Payload Type Encoding Using the Two-Byte Header Format

The APT value is the value is the payload type code of the associated format passed to the rtp generic packetizer before any transformation is applied. The S bit indicates if the media stream can be forwarded safely starting from this RTP packet. Typically, it will be set to 1 on the first rtp packet of an I-Frame video frame and in all rtp audio packets.

Receivers MUST be ready to receive RTP packets with different associated payload types in the same way it would receive different payload type codes on the RTP packets.

The URI for declaring this header extension in an extmap attribute is "urn:ietf:params:rtp-hdrext:associated-payload-type".
   
Layer selection
=======================

SFUs need to have a basic understanding of each frame they receive so they can decide to forward it or not and to which endpoint.
They might need similar information to support media content recording.
This information is either generic to a group of frame (called a stream hereafter) or specific to each frame.

The information is transmitted as a RTP header extension as the RTP packet payload should be treated as opaque by the SFU.
This is especially necessary if the payload is end-to-end encrypted.
The amount of information should be limited to what is strictly necessary to the SFU task since it is not always as trusted as individual peers.

For audio, configuration information such as Opus TOC might be useful.
For video, the following configuration information might include:
- Stream configuration information: resolution, quality, frame rate...
- Codec specific configuration information: codec profile like profile_idc...
- Frame specific information: whether the stream is decodable when starting from this frame, whether the frame is skippable...

For video content, this information can be sent using a Dependency Descriptor header extension.
In that case, the first RTP packet of the frame will have its start_of_frame equal to 1 and the last packet will have its end_of_frame equal to 1.

SDP negotiation
=======================
Each video format will require a different payload type so they can be negotiated by both peers.

fmtp codec includes the FOURCC of the codec.

no need to negotiate the standard packetization for each coded, they are independent

rtx and fec are negotiated normally

Q: should we define what are the negotiated parameters for each codec? should we reuse mpeg/dash ones?


m=video 9 UDP/TLS/RTP/SAVPF 98 100 99 101
a=rtpmap:98 generic/90000
a=fmtp:98 codec=vp09,profile-id=0
a=rtpmap:99 rtx/90000
a=fmtp:99 apt=98
a=rtpmap:100 generic/90000
a=fmtp:100 codec=vp09,profile-id=2
a=rtpmap:101 rtx/90000
a=fmtp:101 apt=100


Security Considerations
=======================

IANA Considerations
===================


--- back
